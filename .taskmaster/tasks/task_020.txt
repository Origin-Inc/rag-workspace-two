# Task ID: 20
# Title: Rebuild Page Editor with Notion/Coda-style Block Architecture
# Status: in-progress
# Dependencies: 6, 14
# Priority: high
# Description: CRITICAL: Complete rebuild of the page editor to implement a production-ready block-based architecture similar to Notion and Coda, replacing the broken drag-and-drop canvas with inline block editing, slash commands, keyboard navigation, and virtual scrolling for optimal performance. This is blocking content creation and must be completed before Task 16 (RAG Infrastructure) since users cannot create content for the RAG system without a functional editor.
# Details:
**CRITICAL PRIORITY**: The editor is currently broken and preventing all content creation. This must be completed before Task 16 (RAG Infrastructure) can be useful, as the RAG system requires content to index.

1. Create new block-based editor foundation with virtual scrolling:
```typescript
interface BlockEditorState {
  blocks: Map<string, EditorBlock>;
  selection: {
    anchor: { blockId: string; offset: number };
    focus: { blockId: string; offset: number };
  };
  virtualScrollState: {
    viewportHeight: number;
    scrollTop: number;
    visibleRange: { start: number; end: number };
    blockHeights: Map<string, number>;
  };
}

interface EditorBlock {
  id: string;
  type: BlockType;
  content: any;
  children?: string[];
  parent?: string;
  metadata: {
    createdAt: Date;
    updatedAt: Date;
    version: number;
  };
}
```

2. Implement slash command system with fuzzy search:
```typescript
class SlashCommandHandler {
  private commands = new Map<string, CommandDefinition>();
  
  registerCommand(command: CommandDefinition) {
    this.commands.set(command.trigger, command);
  }
  
  async handleSlashTrigger(query: string): Promise<CommandSuggestion[]> {
    const fuse = new Fuse(Array.from(this.commands.values()), {
      keys: ['name', 'description', 'aliases'],
      threshold: 0.3
    });
    return fuse.search(query).slice(0, 10);
  }
}
```

3. Build keyboard navigation system:
```typescript
class KeyboardNavigationHandler {
  private shortcuts = new Map<string, NavigationAction>();
  
  constructor() {
    this.registerShortcuts();
  }
  
  private registerShortcuts() {
    this.shortcuts.set('ArrowUp', this.moveToPreviousBlock);
    this.shortcuts.set('ArrowDown', this.moveToNextBlock);
    this.shortcuts.set('Tab', this.indentBlock);
    this.shortcuts.set('Shift+Tab', this.outdentBlock);
    this.shortcuts.set('Cmd+Enter', this.createNewBlock);
    this.shortcuts.set('Cmd+D', this.duplicateBlock);
    this.shortcuts.set('Cmd+Shift+Up', this.moveBlockUp);
    this.shortcuts.set('Cmd+Shift+Down', this.moveBlockDown);
  }
}
```

4. Implement virtual scrolling with react-window:
```typescript
import { VariableSizeList } from 'react-window';
import AutoSizer from 'react-virtualized-auto-sizer';

const VirtualBlockEditor: React.FC = () => {
  const rowHeights = useRef<Map<number, number>>(new Map());
  
  const getItemSize = (index: number) => {
    return rowHeights.current.get(index) || 50;
  };
  
  const setItemSize = (index: number, size: number) => {
    if (rowHeights.current.get(index) !== size) {
      rowHeights.current.set(index, size);
      listRef.current?.resetAfterIndex(index);
    }
  };
  
  return (
    <AutoSizer>
      {({ height, width }) => (
        <VariableSizeList
          ref={listRef}
          height={height}
          width={width}
          itemCount={blocks.length}
          itemSize={getItemSize}
          overscanCount={5}
        >
          {BlockRenderer}
        </VariableSizeList>
      )}
    </AutoSizer>
  );
};
```

5. Create inline block editing with contentEditable:
```typescript
const EditableBlock: React.FC<BlockProps> = ({ block, onUpdate }) => {
  const [isEditing, setIsEditing] = useState(false);
  const contentRef = useRef<HTMLDivElement>(null);
  
  const handleInput = useCallback((e: React.FormEvent) => {
    const content = e.currentTarget.textContent || '';
    onUpdate(block.id, { content });
  }, [block.id, onUpdate]);
  
  return (
    <div
      ref={contentRef}
      contentEditable={isEditing}
      suppressContentEditableWarning
      onFocus={() => setIsEditing(true)}
      onBlur={() => setIsEditing(false)}
      onInput={handleInput}
      className="block-content"
    />
  );
};
```

6. Implement block transformation system:
```typescript
class BlockTransformer {
  async transformBlock(block: EditorBlock, targetType: BlockType): Promise<EditorBlock> {
    const transformer = this.getTransformer(block.type, targetType);
    if (!transformer) {
      throw new Error(`No transformer from ${block.type} to ${targetType}`);
    }
    return transformer(block);
  }
  
  private transformers = new Map<string, TransformFunction>();
  
  registerTransformer(from: BlockType, to: BlockType, fn: TransformFunction) {
    this.transformers.set(`${from}->${to}`, fn);
  }
}
```

7. Add real-time collaboration with Supabase Realtime:
```typescript
const useCollaborativeEditing = (pageId: string) => {
  useEffect(() => {
    const channel = supabase
      .channel(`page:${pageId}`)
      .on('presence', { event: 'sync' }, () => {
        const state = channel.presenceState();
        updateCollaboratorCursors(state);
      })
      .on('broadcast', { event: 'block-update' }, ({ payload }) => {
        applyRemoteBlockUpdate(payload);
      })
      .subscribe();
      
    return () => { channel.unsubscribe(); };
  }, [pageId]);
};
```

8. Performance optimizations:
```typescript
// Debounced save with diff detection
const useDebouncedSave = (blocks: Map<string, EditorBlock>) => {
  const previousBlocks = useRef(blocks);
  
  const saveChanges = useMemo(
    () => debounce(async (changedBlocks: EditorBlock[]) => {
      await supabase
        .from('blocks')
        .upsert(changedBlocks);
    }, 500),
    []
  );
  
  useEffect(() => {
    const changes = diffBlocks(previousBlocks.current, blocks);
    if (changes.length > 0) {
      saveChanges(changes);
      previousBlocks.current = blocks;
    }
  }, [blocks, saveChanges]);
};
```

# Test Strategy:
**CRITICAL: Test that the editor functions at all before Task 16 implementation begins.**

1. Test virtual scrolling performance by creating a page with 10,000+ blocks and verify smooth scrolling at 60fps, memory usage stays under 100MB, and only visible blocks are rendered in DOM (check with React DevTools).

2. Verify slash command functionality by typing '/' in any block and confirming command palette appears within 50ms, fuzzy search works correctly (e.g., '/h1' shows heading options), and selected commands transform blocks properly.

3. Test keyboard navigation by using arrow keys to move between blocks, Tab/Shift+Tab for indentation, Cmd+Enter to create new blocks, and verify all shortcuts work consistently across different block types.

4. Validate inline editing by clicking on any block to enter edit mode, typing to update content, and confirming changes save automatically with debouncing (network tab should show saves every 500ms during continuous typing).

5. Test block transformations by selecting text blocks and converting to headings, lists, code blocks, and verify content is preserved correctly during transformation.

6. Verify real-time collaboration by opening the same page in multiple browser tabs, editing blocks simultaneously, and confirming updates appear in real-time with presence indicators.

7. Load test the editor with various content sizes: empty page, 100 blocks, 1000 blocks, 10000 blocks, and verify initial load time < 1s for pages under 1000 blocks.

8. Test error recovery by simulating network failures during save operations and verify the editor maintains local state and retries failed saves automatically.

9. Validate accessibility by testing keyboard-only navigation, screen reader compatibility, and ARIA labels on all interactive elements.

10. Performance profile the editor using Chrome DevTools to ensure no memory leaks during extended editing sessions (1+ hour) and no performance degradation over time.

11. **CRITICAL: Verify basic content creation works - users must be able to create and save content before Task 16 RAG system can index it.**

# Subtasks:
## 1. Set up Tiptap editor foundation with virtual scrolling [done]
### Dependencies: None
### Description: Replace current PageEditor.tsx with Tiptap-based block editor and implement virtual scrolling for performance
### Details:
Install Tiptap and dependencies (@tiptap/react, @tiptap/starter-kit, @tanstack/react-virtual). Create new BlockEditor component with hierarchical block structure. Implement virtual scrolling to handle 10,000+ blocks efficiently. Set up block state management with Zustand. Create base block rendering pipeline with memoization.
<info added on 2025-08-16T07:12:38.975Z>
Implementation complete. Successfully installed Tiptap dependencies including @tiptap/react, @tiptap/pm, @tiptap/starter-kit, @tiptap/extension-bubble-menu, @tiptap/extension-floating-menu, and @tiptap/extension-placeholder. Created TiptapEditor component at app/components/editor/TiptapEditor.tsx with full rich text formatting capabilities, keyboard shortcuts, and both bubble menu and floating menu for context-aware formatting. Implemented BlockEditor component at app/components/editor/BlockEditor.tsx with react-window virtual scrolling supporting 10,000+ blocks efficiently. Added proper TypeScript types and memoization for optimal performance. The editor foundation is now ready for implementing the block hierarchy, slash commands, and state management system.
</info added on 2025-08-16T07:12:38.975Z>

## 2. Implement command pattern for undo/redo with coalescing [done]
### Dependencies: 20.1
### Description: Build robust undo/redo system with operation coalescing for optimal user experience
### Details:
Create Command interface with execute/undo/canMerge/merge methods. Implement 200ms debounce for continuous operations. Build history stack with 50-state limit. Add operation coalescing for typing and formatting. Create keyboard shortcuts (Cmd+Z, Cmd+Shift+Z).

## 3. Build slash command system with fuzzy search [done]
### Dependencies: 20.1
### Description: Create Notion-style slash command palette with intelligent fuzzy matching
### Details:
Implement SlashCommandHandler with command registry. Add Fuse.js for fuzzy search matching. Create command palette UI with keyboard navigation. Build command categories (basic, formatting, advanced). Add context-aware suggestions. Ensure < 50ms response time.

## 4. Implement keyboard navigation between blocks [done]
### Dependencies: 20.1
### Description: Build comprehensive keyboard navigation system for efficient block manipulation
### Details:
Create KeyboardNavigationHandler with shortcut registry. Implement arrow key navigation between blocks. Add Tab/Shift+Tab for indentation. Build Cmd+Enter for new blocks. Add Cmd+D for duplication. Implement Cmd+Shift+Up/Down for moving blocks.

## 5. Create inline rich text editing with contentEditable [done]
### Dependencies: 20.1, 20.3
### Description: Implement inline editing capabilities within blocks with rich text support
### Details:
Build EditableBlock component with contentEditable. Add rich text formatting (bold, italic, underline, code). Implement focus management and cursor positioning. Create text selection handling. Add paste handling with formatting preservation.

## 6. Build multi-block selection system [done]
### Dependencies: 20.4, 20.5
### Description: Implement multi-block selection for bulk operations
### Details:
Create selection state management. Implement Shift+Click for range selection. Add Cmd+A for select all. Build visual selection indicators. Create bulk operations (delete, move, transform). Add selection keyboard navigation.

## 7. Implement core block types [done]
### Dependencies: 20.5
### Description: Create essential block types: paragraph, headings, lists, code blocks
### Details:
Build paragraph block with rich text. Create heading blocks (h1-h6). Implement ordered/unordered lists with nesting. Add code blocks with Prism.js syntax highlighting. Create block transformation logic between types.

## 8. Add basic advanced block types [pending]
### Dependencies: 20.7, 20.10, 20.11, 20.12, 20.13, 20.14
### Description: Implement embedding, toggle, and callout blocks as advanced block types
### Details:
Create three essential advanced block types: 1) Embedding blocks for external content (YouTube, Twitter, etc.), 2) Toggle blocks for collapsible content sections, 3) Callout blocks for highlighted information boxes. The database block is handled separately in subtasks 20.10-20.14.

## 9. Optimize database with JSONB indexes [done]
### Dependencies: None
### Description: Add performance-critical database indexes and query optimizations
### Details:
Create GIN indexes on JSONB content fields. Add B-tree indexes for frequent queries. Optimize block retrieval queries. Implement efficient bulk operations. Add query performance monitoring.

## 10. Database Block Core Infrastructure [done]
### Dependencies: 20.7
### Description: Implement the foundational database block with schema definition, CRUD operations, and basic table view
### Details:
Create the core database block infrastructure with flexible schema, efficient data storage using JSONB, basic CRUD operations, and a performant table view component. This forms the foundation for the 50,000+ record handling capability.

## 11. Database Block Schema & Storage Layer [done]
### Dependencies: 20.10
### Description: Build the advanced schema system with column types, validation, and optimized storage
### Details:
Implement comprehensive column types (text, number, date, select, multi-select, relation, formula, rollup), validation rules, indexed columns for performance, and JSONB storage optimization for 50k+ records.

## 12. Formula Engine Implementation [done]
### Dependencies: 20.11
### Description: Create the formula evaluation engine with dependency tracking and incremental updates
### Details:
Build a secure formula engine using expr-eval or similar, implement dependency graph tracking, support 40+ built-in functions, enable incremental evaluation for performance, and add formula autocomplete with IntelliSense.

## 13. Database Block Advanced Views & Features [done]
### Dependencies: 20.11
### Description: Implement advanced view types including table, kanban, calendar, gallery, and timeline views
### Details:
Create multiple view types with virtual scrolling, implement filtering and sorting UI, add grouping capabilities, build view-specific features (drag-drop for kanban, date navigation for calendar), and optimize for 50k+ records.

## 14. Database Block Performance & Scale Optimization [in-progress]
### Dependencies: 20.10, 20.11, 20.12, 20.13
### Description: Optimize the database block to handle 50,000+ records with 40+ properties efficiently
### Details:
Implement virtual scrolling with react-window, add Redis caching layer, optimize queries with proper indexes, implement pagination and lazy loading, add performance monitoring, and ensure smooth operation with 50k+ records.

## 15. Implement client-side caching and memoization [pending]
### Dependencies: 20.1
### Description: Add caching layers for optimal performance during editing
### Details:
Implement IndexedDB for block caching. Add React.memo for block components. Create block diff detection. Build intelligent cache invalidation. Add memory management for long sessions.

## 16. Build debounced auto-save with conflict resolution [pending]
### Dependencies: 20.5, 20.15
### Description: Create reliable auto-save system with conflict handling
### Details:
Implement 500ms debounced save. Create diff detection for changed blocks. Build conflict resolution UI. Add offline queue for failed saves. Implement retry logic with exponential backoff.

## 17. Add real-time collaboration infrastructure [pending]
### Dependencies: 20.16
### Description: Implement multi-user editing with Supabase Realtime
### Details:
Set up Supabase Realtime channels. Implement presence tracking with cursors. Build operational transform for conflicts. Add user awareness indicators. Create collaboration permissions.

## 18. Create block plugin system [pending]
### Dependencies: 20.7, 20.8
### Description: Build extensible architecture for custom block types
### Details:
Design plugin API for custom blocks. Create block registry system. Implement plugin lifecycle hooks. Build plugin configuration UI. Add plugin sandboxing for security.

## 19. Implement mobile touch interactions [pending]
### Dependencies: 20.5, 20.6
### Description: Add comprehensive touch support for mobile editing
### Details:
Add touch gesture recognition. Implement long-press for selection. Create touch-friendly block handles. Build mobile-optimized toolbar. Add viewport management for mobile keyboards.

## 20. Add accessibility features [pending]
### Dependencies: 20.4, 20.5
### Description: Ensure WCAG 2.1 AA compliance with comprehensive accessibility
### Details:
Add ARIA labels and roles. Implement screen reader announcements. Create high contrast mode. Build keyboard-only navigation. Add focus indicators and skip links.

## 21. Build content migration tool [pending]
### Dependencies: 20.7
### Description: Create tool to migrate existing canvas-based content to block format
### Details:
Analyze existing page content structure. Build migration transformers for each element type. Create batch migration system. Add rollback capability. Implement migration progress tracking.

## 22. Create comprehensive test suite [pending]
### Dependencies: 20.1, 20.3, 20.5, 20.7
### Description: Build unit, integration, and e2e tests for editor reliability
### Details:
Write unit tests for all components. Create integration tests for features. Build e2e tests with Playwright. Add performance benchmarks. Implement visual regression tests.

## 23. Performance testing and optimization [pending]
### Dependencies: 20.22
### Description: Conduct thorough performance testing and optimization
### Details:
Test with 10,000+ block documents. Profile memory usage patterns. Optimize render performance. Add performance monitoring. Create performance dashboard.

## 24. Cross-browser compatibility testing [pending]
### Dependencies: 20.22
### Description: Ensure editor works across all major browsers
### Details:
Test on Chrome, Firefox, Safari, Edge. Verify feature parity across browsers. Fix browser-specific issues. Add browser detection and polyfills. Create compatibility matrix.

## 25. Production deployment preparation [pending]
### Dependencies: 20.23, 20.24
### Description: Prepare editor for production deployment with monitoring
### Details:
Set up feature flags for gradual rollout. Add error tracking with Sentry. Implement analytics and telemetry. Create rollback procedures. Build admin monitoring dashboard.

## 26. Create base view components for table, kanban, and gallery views [pending]
### Dependencies: 20.1, 20.2
### Description: Implement the foundational view components with proper abstraction for data display, virtual scrolling support, and view-specific interactions while maintaining shared functionality across all view types
### Details:
Build ViewRenderer abstract base component with shared state management, implement TableView with react-window FixedSizeGrid for virtual scrolling, create KanbanView with drag-and-drop columns using @dnd-kit/sortable, develop GalleryView with masonry layout and react-window support, ensure all views integrate with existing DatabaseBlockEnhanced service, implement view configuration storage in database_views table, add ViewContext provider for sharing state between views

## 27. Implement calendar and timeline views with date-based navigation [done]
### Dependencies: None
### Description: Build advanced chronological views with month/week/day display modes for calendar, horizontal timeline with zoom controls, and proper date range calculations for efficient data fetching
### Details:
Create CalendarView component with month grid layout using CSS Grid, implement week and day views with time slots, build TimelineView with horizontal scrolling and zoom levels (day/week/month/quarter/year), add date range picker for navigation, implement smart data fetching based on visible date range, create recurring event support for calendar entries, add drag-to-reschedule functionality for both views, integrate with existing date/datetime column types

## 28. Build advanced filtering and grouping UI with query builder [pending]
### Dependencies: None
### Description: Create sophisticated filter builder with AND/OR logic, nested conditions, saved filter sets, and dynamic grouping capabilities that update views in real-time without full data reload
### Details:
Implement FilterBuilder component with nested condition groups, create filter operators specific to each column type (text contains/starts/ends, number ranges, date before/after/between), build GroupingSelector with multi-level grouping support, add saved filter presets stored per view, implement filter chip display with quick toggle, create server-side filter compilation to SQL WHERE clauses, optimize with indexed columns for common filters, add filter validation and error handling

## 29. Implement view-specific features and interactions [pending]
### Dependencies: None
### Description: Add specialized functionality for each view type including kanban swimlanes, calendar event details, gallery card customization, and timeline milestones with proper performance optimization
### Details:
For Kanban: implement swimlanes with collapsible groups, add WIP limits per column, create card preview on hover, build quick edit inline forms. For Calendar: add event creation by clicking dates, implement recurring events UI, create event detail popover. For Gallery: build card template editor, add image lazy loading with intersection observer, implement masonry vs grid layout toggle. For Timeline: add milestone markers, implement dependency lines between items, create zoom-to-fit functionality

## 30. Optimize rendering performance for 50k+ records across all views [pending]
### Dependencies: None
### Description: Implement advanced performance optimizations including windowing, memoization, request debouncing, and progressive data loading to ensure smooth interaction with massive datasets
### Details:
Implement react-window for all scrollable areas with dynamic item sizes, add React.memo and useMemo for expensive computations, create intersection observer for progressive loading, implement request debouncing (500ms) for filter/sort changes, add IndexedDB caching for recently viewed data, optimize SQL queries with proper indexes and LIMIT/OFFSET, implement virtual DOM recycling for view transitions, add performance monitoring with reportWebVitals, create fallback to pagination if dataset exceeds threshold

