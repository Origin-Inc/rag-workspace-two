# Task ID: 34
# Title: Implement Migration from Project-Based to Notion-Style Subpage Hierarchy
# Status: pending
# Dependencies: 2, 4, 6, 19
# Priority: medium
# Description: Transform the current Workspace→Project→Page structure to a direct Workspace→Page hierarchy with infinite nesting capabilities, preserving all data with zero downtime and enabling natural inheritance through page hierarchies
# Details:
1. **Database Schema Migration with Backwards Compatibility**:
```sql
-- Add hierarchy columns to pages table
ALTER TABLE pages ADD COLUMN parent_id UUID REFERENCES pages(id);
ALTER TABLE pages ADD COLUMN path_ids UUID[] DEFAULT '{}';
ALTER TABLE pages ADD COLUMN depth INTEGER DEFAULT 0;
ALTER TABLE pages ADD COLUMN position INTEGER DEFAULT 0;
ALTER TABLE pages ADD COLUMN is_migrated BOOLEAN DEFAULT FALSE;

-- Create materialized path index for efficient tree queries
CREATE INDEX idx_pages_path_ids ON pages USING GIN (path_ids);
CREATE INDEX idx_pages_parent_id ON pages (parent_id);
CREATE INDEX idx_pages_workspace_parent ON pages (workspace_id, parent_id, position);

-- Create migration tracking table
CREATE TABLE hierarchy_migration_status (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  workspace_id UUID REFERENCES workspaces(id),
  project_id UUID,
  migration_phase TEXT, -- 'preparing', 'migrating', 'validating', 'completed'
  pages_migrated INTEGER DEFAULT 0,
  total_pages INTEGER,
  started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  completed_at TIMESTAMP WITH TIME ZONE
);

-- Function to update materialized paths
CREATE OR REPLACE FUNCTION update_page_paths() RETURNS TRIGGER AS $$
BEGIN
  IF NEW.parent_id IS NULL THEN
    NEW.path_ids = ARRAY[NEW.id];
    NEW.depth = 0;
  ELSE
    SELECT path_ids || NEW.id, depth + 1
    INTO NEW.path_ids, NEW.depth
    FROM pages WHERE id = NEW.parent_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER page_path_trigger
BEFORE INSERT OR UPDATE OF parent_id ON pages
FOR EACH ROW EXECUTE FUNCTION update_page_paths();
```

2. **Zero-Downtime Migration Strategy**:
```typescript
// app/services/hierarchy-migration.server.ts
export class HierarchyMigrationService {
  async migrateWorkspace(workspaceId: string, options: MigrationOptions) {
    // Phase 1: Prepare dual-write mode
    await this.enableDualWriteMode(workspaceId);
    
    // Phase 2: Migrate existing project structure
    const projects = await prisma.project.findMany({
      where: { workspaceId },
      include: { pages: true }
    });
    
    for (const project of projects) {
      // Create project as top-level page
      const projectPage = await prisma.page.create({
        data: {
          workspaceId,
          title: project.name,
          type: 'project_container',
          parent_id: null,
          metadata: { originalProjectId: project.id },
          is_migrated: true
        }
      });
      
      // Migrate project pages as children
      await this.migrateProjectPages(project.pages, projectPage.id);
    }
    
    // Phase 3: Switch read path to new hierarchy
    await this.switchReadPath(workspaceId);
    
    // Phase 4: Validate and cleanup
    await this.validateMigration(workspaceId);
  }
  
  async enableDualWriteMode(workspaceId: string) {
    // Configure service layer to write to both old and new structures
    await prisma.workspaceConfig.upsert({
      where: { workspaceId },
      create: { workspaceId, dualWriteEnabled: true },
      update: { dualWriteEnabled: true }
    });
  }
}
```

3. **Service Layer Modifications for Hierarchy Permissions**:
```typescript
// app/services/page-hierarchy.server.ts
export class PageHierarchyService {
  async getPageWithAncestors(pageId: string) {
    const page = await prisma.$queryRaw`
      WITH RECURSIVE page_tree AS (
        SELECT * FROM pages WHERE id = ${pageId}
        UNION ALL
        SELECT p.* FROM pages p
        INNER JOIN page_tree pt ON p.id = pt.parent_id
      )
      SELECT * FROM page_tree ORDER BY depth;
    `;
    return page;
  }
  
  async checkInheritedPermissions(userId: string, pageId: string) {
    const ancestors = await this.getPageWithAncestors(pageId);
    
    // Check permissions from root to leaf
    for (const ancestor of ancestors) {
      const permission = await prisma.pagePermission.findFirst({
        where: {
          pageId: ancestor.id,
          OR: [
            { userId },
            { role: { users: { some: { id: userId } } } }
          ]
        }
      });
      
      if (permission) {
        return this.mergePermissions(permission, ancestor.depth);
      }
    }
    
    return null;
  }
  
  async moveSubtree(pageId: string, newParentId: string | null) {
    // Get all descendants
    const descendants = await prisma.$queryRaw`
      SELECT id, path_ids, depth FROM pages
      WHERE ${pageId} = ANY(path_ids)
      ORDER BY depth;
    `;
    
    // Update paths in transaction
    await prisma.$transaction(async (tx) => {
      for (const desc of descendants) {
        const newPath = await this.calculateNewPath(desc.id, newParentId);
        await tx.page.update({
          where: { id: desc.id },
          data: { path_ids: newPath, depth: newPath.length - 1 }
        });
      }
    });
  }
}
```

4. **API Endpoints for Page Tree Operations**:
```typescript
// app/routes/api.pages.$pageId.tree.ts
export const loader: LoaderFunction = async ({ params }) => {
  const tree = await prisma.$queryRaw`
    WITH RECURSIVE page_tree AS (
      SELECT *, 0 as level FROM pages WHERE id = ${params.pageId}
      UNION ALL
      SELECT p.*, pt.level + 1 FROM pages p
      INNER JOIN page_tree pt ON p.parent_id = pt.id
    )
    SELECT * FROM page_tree ORDER BY level, position;
  `;
  
  return json({ tree: buildTreeStructure(tree) });
};

// app/routes/api.pages.move.ts
export const action: ActionFunction = async ({ request }) => {
  const { pageId, targetParentId, position } = await request.json();
  
  // Validate no circular references
  if (targetParentId) {
    const isDescendant = await checkIfDescendant(pageId, targetParentId);
    if (isDescendant) {
      return json({ error: 'Cannot move page to its own descendant' }, 400);
    }
  }
  
  await pageHierarchyService.moveSubtree(pageId, targetParentId);
  return json({ success: true });
};
```

5. **UI Components for Nested Navigation**:
```typescript
// app/components/PageTree.tsx
export function PageTree({ workspaceId, currentPageId }: PageTreeProps) {
  const [expanded, setExpanded] = useState<Set<string>>(new Set());
  const { data: tree } = useFetcher();
  
  return (
    <DndContext onDragEnd={handleDragEnd}>
      <SortableContext items={tree.pages}>
        <TreeNode
          pages={tree.pages}
          level={0}
          expanded={expanded}
          onToggle={toggleExpanded}
          currentPageId={currentPageId}
        />
      </SortableContext>
    </DndContext>
  );
}

// app/components/TreeNode.tsx
function TreeNode({ page, level, children }: TreeNodeProps) {
  const { attributes, listeners, setNodeRef, transform } = useSortable({
    id: page.id,
    data: { type: 'page', page }
  });
  
  return (
    <div
      ref={setNodeRef}
      style={{
        transform: CSS.Transform.toString(transform),
        paddingLeft: `${level * 20}px`
      }}
      {...attributes}
      {...listeners}
    >
      <div className="flex items-center gap-2">
        {children?.length > 0 && <ChevronIcon />}
        <PageIcon type={page.type} />
        <span>{page.title}</span>
      </div>
      {expanded && children && (
        <div className="ml-4">
          {children.map(child => (
            <TreeNode key={child.id} page={child} level={level + 1} />
          ))}
        </div>
      )}
    </div>
  );
}
```

6. **AI Context Flow Through Hierarchies**:
```typescript
// app/services/ai-hierarchy-context.server.ts
export class AIHierarchyContextService {
  async buildHierarchicalContext(pageId: string, maxDepth = 3) {
    const context = [];
    
    // Get ancestors for context
    const ancestors = await this.getAncestors(pageId, maxDepth);
    for (const ancestor of ancestors) {
      context.push({
        level: 'ancestor',
        depth: ancestor.depth,
        content: await this.summarizePage(ancestor.id),
        metadata: ancestor.metadata
      });
    }
    
    // Get current page context
    const currentPage = await this.getPageWithBlocks(pageId);
    context.push({
      level: 'current',
      content: currentPage,
      fullContent: true
    });
    
    // Get children summaries
    const children = await this.getChildren(pageId, 1);
    for (const child of children) {
      context.push({
        level: 'child',
        content: await this.summarizePage(child.id),
        metadata: child.metadata
      });
    }
    
    return this.formatContextForAI(context);
  }
}
```

# Test Strategy:
1. **Migration Integrity Tests**:
   - Create test workspace with 100 projects containing 1000 total pages
   - Run migration and verify all pages are accessible through new hierarchy
   - Confirm no data loss by comparing checksums of page content before/after
   - Verify all project→page relationships are preserved as parent→child

2. **Zero Downtime Validation**:
   - Start migration on active workspace with simulated user traffic
   - Monitor API response times stay under 200ms during migration
   - Verify dual-write mode maintains consistency between old and new structures
   - Test rollback mechanism can revert to project structure if needed

3. **Hierarchy Operations Testing**:
   - Test moving page with 50 descendants completes in under 2 seconds
   - Verify circular reference prevention when attempting invalid moves
   - Test depth limits (max 10 levels) are enforced
   - Confirm path_ids array updates correctly for all descendants

4. **Permission Inheritance Tests**:
   - Create 5-level deep hierarchy with different permissions at each level
   - Verify user access correctly inherits from nearest ancestor with permissions
   - Test permission changes propagate to descendants within 100ms
   - Confirm workspace admin can always access all pages regardless of hierarchy

5. **UI Component Tests**:
   - Load tree with 1000 nodes and verify rendering under 500ms
   - Test drag-and-drop moves update database and UI correctly
   - Verify expand/collapse state persists across page refreshes
   - Test keyboard navigation through tree structure

6. **AI Context Flow Tests**:
   - Create hierarchy with rich content at multiple levels
   - Verify AI receives appropriate context from ancestors (summaries) and current page (full)
   - Test context size limits are respected (max 50KB per request)
   - Confirm AI can reference parent page information when generating child content

# Subtasks:
## 1. Database Schema Migration - Make projectId Optional [pending]
### Dependencies: None
### Description: Modify pages table to make projectId nullable while preserving existing data and relationships
### Details:
1. Create migration file: prisma/migrations/make_project_id_optional
2. Alter pages table: ALTER TABLE pages ALTER COLUMN project_id DROP NOT NULL
3. Ensure workspace_id is set for all pages from their projects
4. Add indexes for workspace-based queries
5. Update Prisma schema to reflect nullable projectId
6. Test with existing data to ensure no breaks

## 2. Create Page Hierarchy Service Layer [pending]
### Dependencies: None
### Description: Implement PageHierarchyService with methods for managing page trees, permissions inheritance, and navigation
### Details:
File: app/services/page-hierarchy.server.ts
Methods to implement:
- createWorkspacePage(): Create pages directly under workspace
- validatePageHierarchyPermissions(): Check permissions through parent chain
- getPageWithAncestors(): Retrieve page with full ancestor chain
- moveSubtree(): Move page and all descendants to new parent
- getPagePath(): Build breadcrumb path for page
- checkCircularReference(): Prevent page becoming its own ancestor

## 3. Remove Project-Specific Routes and APIs [pending]
### Dependencies: None
### Description: Remove or redirect all 17 project-dependent routes and 9 project-specific API endpoints
### Details:
Files to modify/remove:
- app/routes/projects.tsx
- app/routes/projects.$projectId.tsx
- app/routes/app.projects._index.tsx
- app/routes/app.projects.new.tsx
- app/routes/app.project.$projectId.tsx
- app/routes/api.projects.tsx
- app/routes/api.projects.search.tsx
- app/routes/api.projects.$projectId.pages.tsx
- app/routes/api.projects.$projectId.collaborators.tsx
Create redirects from old URLs to new workspace/page structure

## 4. Build PageTreeNavigation UI Component [pending]
### Dependencies: None
### Description: Create React component for nested page navigation with expand/collapse, drag-and-drop, and visual hierarchy
### Details:
File: app/components/navigation/PageTreeNavigation.tsx
Features:
- Recursive tree rendering with infinite nesting
- Expand/collapse state management with localStorage persistence
- Drag-and-drop to reorganize pages (using @dnd-kit/sortable)
- Visual indentation based on depth level
- Current page highlighting
- Keyboard navigation support (arrow keys)
- Context menu for page operations (create child, delete, rename)

## 5. Create Data Migration Script for Existing Projects [pending]
### Dependencies: None
### Description: Build script to migrate all existing project-page relationships to workspace-page hierarchy structure
### Details:
File: scripts/migrate-projects-to-pages.ts
Operations:
1. For each project, create a root page with project metadata
2. Update all pages to set workspace_id from their project
3. Transform project pages into children of new root page
4. Preserve all page content, blocks, and metadata
5. Create migration log for rollback capability
6. Batch processing for large datasets (process 100 pages at a time)
7. Progress tracking and error recovery

## 6. Update Editor Route for Direct Page Access [pending]
### Dependencies: None
### Description: Modify editor.$pageId.tsx to work without project context and validate permissions through page hierarchy
### Details:
File: app/routes/editor.$pageId.tsx
Changes:
1. Remove project fetching and validation (lines 22-30)
2. Check workspace access directly through page.workspaceId
3. Update permission checks to use PageHierarchyService
4. Modify breadcrumb generation to show page ancestry
5. Update page creation to work without projectId
6. Ensure block editor receives correct hierarchy context

## 7. Implement AI Hierarchical Context Service [pending]
### Dependencies: None
### Description: Create service to provide AI with page hierarchy context including parent, ancestors, and sibling information
### Details:
File: app/services/ai/page-context-hierarchy.server.ts
Functions:
1. getHierarchicalContext(): Retrieve full page context with ancestors/descendants
2. resolveParentContext(): Support @parent context reference in AI commands
3. resolveAncestorsContext(): Support @ancestors context reference
4. extractPageSummary(): Generate summaries for parent/child context
5. buildContextPrompt(): Format hierarchy data for AI consumption
6. Support context depth limits to manage token usage

## 8. Update Main App Navigation Sidebar [pending]
### Dependencies: None
### Description: Replace project-based navigation in app.tsx sidebar with page tree navigation
### Details:
File: app/routes/app.tsx
Changes needed (lines 286-333):
1. Remove Projects section with expand/collapse
2. Replace with PageTreeNavigation component
3. Update navigation to fetch workspace root pages
4. Remove 'New project' link, add 'New page' action
5. Update state management for expanded pages instead of projects
6. Ensure navigation updates when pages are created/moved

## 9. Create Comprehensive Test Suite for Migration [pending]
### Dependencies: None
### Description: Build tests to validate data integrity, permission inheritance, and UI functionality during and after migration
### Details:
Files: app/services/__tests__/page-hierarchy.test.ts, scripts/__tests__/migration.test.ts
Test cases:
1. Verify all pages accessible after migration
2. Test permission inheritance through 5-level hierarchy
3. Validate no circular references in page moves
4. Ensure workspace isolation maintained
5. Test rollback restores original project structure
6. Verify UI tree renders 1000+ pages efficiently
7. Test AI context includes correct ancestor information

## 10. Implement Rollback Strategy and Safety Mechanisms [pending]
### Dependencies: None
### Description: Create emergency rollback procedure and monitoring to safely revert to project structure if issues arise
### Details:
File: scripts/rollback-to-projects.ts
Components:
1. Backup current state before migration begins
2. Track migration progress in database table
3. Implement rollback script to restore project structure
4. Create health checks for hierarchy operations
5. Add feature flags for gradual rollout
6. Monitor query performance during transition
7. Set up alerts for anomalies in page access patterns
8. Document rollback procedures for operations team

