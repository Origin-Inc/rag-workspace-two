# Task ID: 6
# Title: Implement RAG System with Vector Search
# Status: done
# Dependencies: 5
# Priority: medium
# Description: Build the retrieval-augmented generation system with document chunking, embedding generation, Supabase pgvector storage, hybrid search capabilities, and workspace summarization features
# Details:
1. Enable pgvector extension in Supabase:
```sql
CREATE EXTENSION IF NOT EXISTS vector;

CREATE TABLE documents (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  workspace_id UUID REFERENCES workspaces(id),
  content TEXT NOT NULL,
  embedding vector(1536),
  metadata JSONB,
  storage_path TEXT,
  source_block_id UUID, -- Reference to source block/page
  passage_id TEXT, -- Unique identifier for citation
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create HNSW index for vector similarity
CREATE INDEX documents_embedding_idx ON documents 
USING hnsw (embedding vector_cosine_ops);

-- Create index for passage retrieval
CREATE INDEX documents_passage_idx ON documents(passage_id);

-- Enable RLS
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- RLS policies based on workspace membership
CREATE POLICY "Users can view documents in their workspace"
  ON documents FOR SELECT
  USING (workspace_id IN (
    SELECT workspace_id FROM workspace_members 
    WHERE user_id = auth.uid()
  ));
```
2. Use Supabase Storage for document uploads:
```typescript
const { data, error } = await supabase.storage
  .from('documents')
  .upload(`workspace-${workspaceId}/${filename}`, file);
```
3. Create Supabase Edge Function for embedding generation with passage tracking:
```typescript
// supabase/functions/generate-embeddings/index.ts
const embedding = await openai.embeddings.create({
  model: "text-embedding-3-small",
  input: chunkText
});

await supabase.from('documents').insert({
  workspace_id,
  content: chunkText,
  embedding: embedding.data[0].embedding,
  storage_path,
  source_block_id: blockId,
  passage_id: `${blockId}-${chunkIndex}`,
  metadata: {
    page_name: pageName,
    block_type: blockType,
    importance_score: calculateImportance(chunkText)
  }
});
```
4. Implement workspace summarization RPC function:
```sql
CREATE OR REPLACE FUNCTION summarize_workspace(
  workspace_uuid uuid,
  summary_type text DEFAULT 'comprehensive'
)
RETURNS TABLE (
  summary text,
  key_pages jsonb,
  important_items jsonb,
  citations jsonb
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Retrieve top documents by importance and recency
  WITH relevant_docs AS (
    SELECT 
      content,
      metadata,
      passage_id,
      source_block_id
    FROM documents
    WHERE workspace_id = workspace_uuid
    ORDER BY 
      (metadata->>'importance_score')::float DESC,
      created_at DESC
    LIMIT 50
  )
  -- Return structured summary data
  SELECT 
    generate_summary(array_agg(content)),
    extract_key_pages(array_agg(metadata)),
    extract_important_items(array_agg(content)),
    array_agg(json_build_object(
      'passage_id', passage_id,
      'block_id', source_block_id
    ))
  FROM relevant_docs;
END;
$$;
```
5. Implement hybrid search with citation support:
```sql
CREATE OR REPLACE FUNCTION hybrid_search(
  query_embedding vector(1536),
  query_text text,
  workspace_uuid uuid,
  match_count int DEFAULT 20
)
RETURNS TABLE (
  id uuid,
  content text,
  similarity float,
  rank float,
  passage_id text,
  source_block_id uuid,
  metadata jsonb
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  WITH vector_search AS (
    SELECT 
      d.id,
      d.content,
      d.passage_id,
      d.source_block_id,
      d.metadata,
      1 - (d.embedding <=> query_embedding) as similarity
    FROM documents d
    WHERE d.workspace_id = workspace_uuid
    ORDER BY d.embedding <=> query_embedding
    LIMIT match_count
  ),
  fts_search AS (
    SELECT 
      d.id,
      ts_rank(to_tsvector('english', d.content), 
              plainto_tsquery('english', query_text)) as rank
    FROM documents d
    WHERE d.workspace_id = workspace_uuid 
      AND to_tsvector('english', d.content) @@ plainto_tsquery('english', query_text)
  )
  SELECT 
    v.id,
    v.content,
    v.similarity,
    COALESCE(f.rank, 0) as rank,
    v.passage_id,
    v.source_block_id,
    v.metadata
  FROM vector_search v
  LEFT JOIN fts_search f ON v.id = f.id
  ORDER BY (v.similarity + COALESCE(f.rank, 0)) DESC;
END;
$$;
```
6. Use Supabase client for workspace summarization:
```typescript
// Workspace summarization command
if (query.toLowerCase().includes('summarize this workspace')) {
  const { data: summary } = await supabase.rpc('summarize_workspace', {
    workspace_uuid: workspaceId,
    summary_type: 'comprehensive'
  });
  
  // Format response with citations
  return formatSummaryWithCitations(summary);
}

// Vector similarity search with citations
const { data } = await supabase.rpc('hybrid_search', {
  query_embedding: embedding,
  query_text: searchText,
  workspace_uuid: workspaceId
});
```

# Test Strategy:
Test document uploads to Supabase Storage with passage tracking. Verify Edge Functions generate embeddings with proper metadata. Test workspace summarization returns coherent summaries with page names and key items. Verify citation system correctly references passage IDs and block IDs. Test RPC hybrid search function returns relevant results with source attribution. Verify RLS policies enforce workspace access. Test full-text search integration. Benchmark retrieval performance < 500ms. Test 'Summarize this workspace' command returns comprehensive overview with citations.

# Subtasks:
## 1. Enable pgvector and create document schema in Supabase [done]
### Dependencies: None
### Description: Enable pgvector extension and create documents table with vector columns, RLS policies, HNSW indexes, and citation tracking fields
### Details:
Enable pgvector extension in Supabase dashboard or via SQL. Create documents table with vector(1536) column, workspace references, metadata JSONB, storage_path for file references, source_block_id for block references, and passage_id for citation tracking. Set up RLS policies based on workspace membership. Add indexes for passage retrieval.

## 2. Configure Supabase Storage buckets for documents [done]
### Dependencies: 6.1
### Description: Set up Supabase Storage buckets with appropriate policies for document uploads and retrieval
### Details:
Create 'documents' bucket in Supabase Storage. Configure RLS policies for upload/download based on workspace membership. Set up file size limits and allowed MIME types (PDF, DOCX, TXT, MD).

## 3. Implement document chunking Edge Function with metadata extraction [done]
### Dependencies: 6.2
### Description: Create Supabase Edge Function for intelligent text chunking with token-aware splitting and importance scoring
### Details:
Build Edge Function that processes uploaded documents, chunks them into 500-1500 tokens with 100 token overlap using tiktoken. Handle different file formats and preserve context boundaries. Extract page names, block types, and calculate importance scores for each chunk. Generate unique passage IDs for citation.

## 4. Build embedding generation Edge Function with citation support [done]
### Dependencies: 6.3
### Description: Create Edge Function for generating embeddings using OpenAI's API with batch processing and passage tracking
### Details:
Implement Edge Function that generates embeddings for document chunks using OpenAI's text-embedding-3-small model. Include rate limiting, error handling, and batch processing. Store embeddings directly in Supabase tables with source_block_id and passage_id for citations. Include metadata with page names and importance scores.

## 5. Create hybrid search RPC function with citation retrieval [done]
### Dependencies: 6.1, 6.4
### Description: Build Supabase RPC function combining vector similarity and full-text search with source attribution
### Details:
Create PostgreSQL RPC function in Supabase that combines pgvector cosine similarity with PostgreSQL full-text search. Support configurable weights and result limits. Return combined relevance scores along with passage_id, source_block_id, and metadata for proper citation in responses.

## 6. Implement Supabase full-text search indexes [done]
### Dependencies: 6.1
### Description: Set up PostgreSQL full-text search with tsvector columns and GIN indexes
### Details:
Add tsvector column to documents table with GIN index. Create triggers to automatically update tsvector on content changes. Configure text search configuration for English with proper stemming.

## 7. Build document upload API with Supabase Storage [done]
### Dependencies: 6.2, 6.4
### Description: Create API endpoints that handle file uploads to Supabase Storage and trigger processing
### Details:
Implement upload endpoints using Supabase Storage client. Support resumable uploads for large files. Trigger Edge Function for processing after successful upload. Track upload progress and handle errors.

## 8. Create search API using Supabase client [done]
### Dependencies: 6.5, 6.6
### Description: Build search endpoints leveraging Supabase RPC functions and text search
### Details:
Create API endpoints that call Supabase RPC hybrid_search function. Implement fallback to textSearch for simple queries. Add result caching and pagination using Supabase's built-in features.

## 9. Implement RLS policies for document access [done]
### Dependencies: 6.1
### Description: Create comprehensive Row Level Security policies for document operations
### Details:
Set up RLS policies for SELECT, INSERT, UPDATE, DELETE operations based on workspace membership. Create policies for document sharing and public access. Ensure policies work with vector search operations.

## 10. Build context retrieval with Supabase functions [done]
### Dependencies: 6.8
### Description: Create optimized context retrieval using Supabase database functions
### Details:
Implement database functions for query expansion, document re-ranking, and context window optimization. Use Supabase's compute for efficient processing. Include relevance scoring adjustments.

## 11. Create prompt templates with Supabase integration [done]
### Dependencies: 6.10
### Description: Design prompt templates that efficiently use retrieved context from Supabase
### Details:
Build prompt templates stored in Supabase tables. Support dynamic context injection from search results. Include token counting and truncation strategies. Store templates with versioning.

## 12. Implement monitoring with Supabase observability [done]
### Dependencies: 6.8
### Description: Set up performance monitoring using Supabase's built-in analytics and logging
### Details:
Use Supabase's query performance insights for vector search optimization. Monitor Edge Function execution times. Track Storage usage and API call patterns. Set up alerts for performance degradation.

## 13. Build workspace summarization RPC function [done]
### Dependencies: 6.5
### Description: Create Supabase RPC function that generates comprehensive workspace summaries with key page identification
### Details:
Implement PostgreSQL RPC function that retrieves top documents by importance score and recency. Extract key page names and important items from metadata. Generate coherent summary with proper structure. Return citations with passage IDs and block references for source attribution.

## 14. Implement summarization command handler [done]
### Dependencies: 6.13
### Description: Create API endpoint and frontend handler for 'Summarize this workspace' command
### Details:
Build command parser to detect summarization requests. Call workspace summarization RPC function. Format response with citations linking to original passages and blocks. Support different summary types (comprehensive, brief, focused). Include key page names and important items in formatted output.

## 15. Create citation formatting system [done]
### Dependencies: 6.14
### Description: Build system to format and display citations with passage IDs and block references
### Details:
Create citation formatter that converts passage IDs to clickable references. Link citations to source blocks in the UI. Display inline citations in summary responses. Support hover previews of cited content. Maintain citation consistency across different response types.

